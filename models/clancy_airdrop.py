from odoo import models, fields, api, _
#from odoo.osv import expression   

import logging
_logger = logging.getLogger(__name__)
_logger.setLevel(logging.INFO)


class ClancyAirdrop(models.Model):
    _name = 'clancy.airdrop'
    _description = 'Clancy AirDrop by Clancyworld'

    name = fields.Char(string='Name', required=True)
    query = fields.Char(string='Query', default='')
    assigned_product_id = fields.Many2one('product.product', string='Assigned Product', required=True)
    publishing_date = fields.Date(string='Publishing Date', required=True)
    state = fields.Selection(
        [('draft', 'Draft'), ('validated', 'Validated'), ('canceled', 'Canceled')],
        string='Status', readonly=True, default='draft', required=True
    )

    @api.constrains('publishing_date')
    def _check_publishing_date(self):
        today = fields.Date.today()
        for record in self:
            if record.publishing_date < today:
                raise ValidationError(_("Publishing date must be in the future."))

    def retrieve_users(self):
        """
        Retrieve a set of users based on the defined query or custom query
        """
        domain = []
        if self.query:
            # Parse the query string using the QueryTool class
            domain = QueryTool.parse(self.query)
        else:
            # If no query is defined, retrieve all partners
            domain = [('active', '=', True)]
        return self.env['res.partner'].search(domain)

    def generate_sales_orders(self):
        """
        Generate sales orders for each user retrieved by the query
        """
        users = self.retrieve_users()
        product = self.assigned_product_id
        publishing_date = self.publishing_date
        orders = []
        for user in users:
            order = self.env['sale.order'].create({
                'partner_id': user.id,
                'order_line': [(0, 0, {
                    'product_id': product.id,
                    'product_uom_qty': 1,
                    'price_unit': product.list_price,
                    'name': product.name,
                })],
                'validity_date': publishing_date,
            })
            orders.append(order)
        return orders

    def generate_invoices(self):
        """
        Generate invoices for the sales orders generated by generate_sales_orders()
        """
        orders = self.generate_sales_orders()
        invoices = []
        for order in orders:
            invoice = order._create_invoices()
            invoices.append(invoice)
        return invoices

    def action_validate(self):
        """
        Change the state of the airdrop to 'validated'
        """
        self.write({'state': 'validated'})

    def action_cancel(self):
        """
        Change the state of the airdrop to 'canceled'
        """
        self.write({'state': 'canceled'})


class QueryTool:
    """
    Helper class for building and parsing search queries
    """

    OPERATORS = {
        '=': 'equals',
        '!=': 'not equals',
        '>': 'greater than',
        '>=': 'greater than or equal to'
    }

    @classmethod
    def parse(cls, query_string):
        """
        Parse a search query string into a list of domain tuples
        """
        criteria_list = query_string.strip().split(';')
        domain = []
        for criterion in criteria_list:
            if criterion:
                field, operator, value = cls._parse_criterion(criterion)
                domain.append((field, operator, value))
        return domain
    
    @classmethod
    def build(cls, domain):
        """
        Build a search query string from a list of domain tuples
        """
        criteria_list = []
        for criterion in domain:
            field, operator, value = criterion
            criteria_list.append(cls._build_criterion(field, operator, value))
        return ';'.join(criteria_list)
    
    @classmethod
    def _parse_criterion(cls, criterion):
        """
        Parse a single search criterion string into a tuple of field, operator, and value
        """
        for op in cls.OPERATORS:
            if op in criterion:
                field, value = criterion.split(op)
                operator = op
                break
        else:
            raise ValueError(f'Invalid operator in criterion "{criterion}"')
        
        field = field.strip()
        operator = operator.strip()
        value = value.strip()
        
        return field, operator, value
    
    @classmethod
    def _build_criterion(cls, field, operator, value):
        """
        Build a single search criterion string from a tuple of field, operator, and value
        """
        operator = cls.OPERATORS.get(operator, operator)
        return f'{field} {operator} {value}'
